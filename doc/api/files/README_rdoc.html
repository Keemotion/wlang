<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>File: README.rdoc</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



  <div id="fileHeader">
    <h1>README.rdoc</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>README.rdoc
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Wed Jan 13 16:11:53 +0100 2010</td>
    </tr>
    </table>
  </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <h1>What is <em>wlang</em> ?</h1>
<p>
<em>wlang</em> is a simple, powerful, robust and secure <b>code
generation</b>/<b>templating engine</b> (at least, authors hope so ;-)
Motivation for it can be found at <a
href="http://www.revision-zero.org/wlang">www.revision-zero.org/wlang</a>.
It&#8216;s main aim is to help you creating web pages, sql queries, ruby
code (that is, generating code in general) without having to worry too much
about html entities encoding, sql back quoting, string escaping and the
like. <a href="../classes/WLang.html">WLang</a> proposes a generic engine
that you can extend to fit your needs. It also proposes standard
instantiations of this engine for common tasks such as creating SQL
queries, instantiating web pages, etc.
</p>
<h2>Roadmap</h2>
<ul>
<li>For terminology and a quick overview of <em>wlang</em> for generating code,
read on.

</li>
<li>For the current cheatsheet/specification see the file
doc/specification/specification.html

</li>
<li>If you want to learn <em>wlang</em> quickly, see the example directory or
read examples in the specification file (if you understand all examples in
the specification file, then you probably master wlang.

</li>
<li>If you want a killer example (but simple) see the way the
specification.html file is generated in doc/specification directory

</li>
<li>If you want to know which dialects are available (that is, in which target
languages you can generate code), see the specification as well or read the
file lib/wlang/dialects/standard_dialects.rb in the source distribution.

</li>
<li>If you want to create your own wlang dialect, see <a
href="../classes/WLang/Dialect/DSL.html">WLang::Dialect::DSL</a>

</li>
<li>If you think that your own dialect is of generic purpose and well-designed,
if you have any question or want to contribute join us on <a
href="http://github.com/blambeau/wlang">github</a>.

</li>
</ul>
<h2>Overview</h2>
<p>
(for bold words, see terminology later) Basic usage of <em>wlang</em> is as
follows: you have a <b>template</b> file (written in a given <em>wlang</em>
<b>dialect</b>), you have some instantiation <b>context</b> (data provided
through a Ruby Hash or a yaml file for example) and you would like to
instantiate the template with that data.
</p>
<p>
Example: a template.whtml as follows
</p>
<pre>
  &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;${title}&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;h1&gt;Hello ${who} !&lt;/h1&gt;
    &lt;/body&gt;
  &lt;/html&gt;
</pre>
<p>
Instantiation data is a hash containing values for <em>title</em> and
<em>who</em>. Instantiating the template is straightforward:
</p>
<pre>
  require 'wlang'
  context = {&quot;title&quot; =&gt; &quot;Hello world in WLang&quot;, &quot;who&quot; =&gt; &quot;Alice&quot;}
  WLang.file_instantiate(&quot;template.whtml&quot;, context, STDOUT)
</pre>
<h3>Seems magic &#8230; but is not!</h3>
<ul>
<li>first of all, it <b>does not allow XSS attacks</b>: even if <em>who</em> is
a value like <tt>&#8217;&lt;script&gt;[some javascript
code]&lt;/script&gt;&#8217;</tt>, it will be automatically entities-encoded
and will appear for itself, not allowing the browser to interpret it as
javascript code.

</li>
<li><b>it is not hardcoded</b>, but uses <em>wlang</em> shortcuts:

<ul>
<li>as you did not specify the <em>wlang</em> dialect of your template, it has
been infered as &#8216;wlang/xhtml&#8217; from the file extension.

</li>
<li>in this dialect, the wlang rule associated with the tag ${&#8230;}
(<tt>${who}</tt> for example) automatically replaces the tag by the context
data under &#8216;who&#8217; (in the hash), while taking care of applying
entities-encoding.

</li>
</ul>
</li>
<li><b>${&#8230;} is only one available tag</b>. Actuall <em>wlang</em>
dialects come with a lot of useful tags that provide shortuct to common
tasks &#8230; entities-encoding is only one !

</li>
</ul>
<h2>Terminology</h2>
<p>
<em>wlang</em> comes with a well-defined terminology for the underlying
abstractions. As the documentation uses it, you&#8216;ll probably be happy
to learn about the main abstractions and associated terms.
</p>
<dl>
<dt>template</dt><dd>Source code respecting the wlang grammar, and attached to a given <em>wlang
dialect</em>. Asbtraction implemented by <a
href="../classes/WLang/Template.html">WLang::Template</a>.

</dd>
<dt>dialect</dt><dd>Basically, <em>dialect</em> is used as a synonym for (programming)
<em>language</em>. However <em>wlang</em> uses a tree of dialects, allowing
specializations: <tt>sql/sybase</tt> for example is the qualified name of a
sub-dialect &#8216;sybase&#8217; of the &#8216;sql&#8217; dialect. Dialects
come with associated <em>encoders</em>. Abstraction implemented by <a
href="../classes/WLang/Dialect.html">WLang::Dialect</a>.

</dd>
<dt>wlang dialect</dt><dd>When we talk about a <em>wlang dialect</em>, we are actually refering to
some specialization of the wlang tag-based grammar: <tt>wlang/xhtml</tt>
for example is the templating language <em>wlang</em> proposes to generate
xhtml pages. An example of source code in that dialect has been shown
before. In addition to its encoders a <em>wlang dialect</em> comes with its
sets of <em>tags</em> and associated <em>rules</em>. Abstraction
implemented by <a href="../classes/WLang/Dialect.html">WLang::Dialect</a>
as well as <a href="../classes/WLang/EncoderSet.html">WLang::EncoderSet</a>
and <a href="../classes/WLang/RuleSet.html">WLang::RuleSet</a>.

</dd>
<dt>encoder set</dt><dd>Reusable set of <em>encoders</em>, attached to a dialect. Abstraction
implemented by <a
href="../classes/WLang/EncoderSet.html">WLang::EncoderSet</a>.

</dd>
<dt>encoder</dt><dd>Text transformation (algorithm) applying some encoding conventions of a
portion of a the target language generated by a dialect. HTML
entities-encoding, SQL&#8216;s back-quoting are examples of encoders.
Encoders are accessible through their qualified name:
xhtml/entities-encoding and sql/back-quoting in the examples. Abstraction
implemented by <a href="../classes/WLang/Encoder.html">WLang::Encoder</a>.

</dd>
<dt>ruleset</dt><dd>Reusable set of <em>tags</em> associated to <em>rule</em>s. Abstraction
implemented by <a href="../classes/WLang/RuleSet.html">WLang::RuleSet</a>.

</dd>
<dt>wlang tag</dt><dd>Special tags in the template, starting with wlang symbols and a number of
wlang blocks. A tag is associated with a wlang rule. Examples:
<tt>${&#8230;}</tt> is a tag with only one block, while
<tt>?{&#8230;}{&#8230;}{&#8230;}</tt> is another tag but with three blocks.

</dd>
<dt>rule</dt><dd>Transformation semantics of a given <em>tag</em>. When wlang instantiates a
template it simply replaces <em>wlang tags</em> by some <em>replacement
value</em> (which is always a string). This value is computed by the rule
attached to the tag. Rule definition explicitly describes the number of
blocks it expects, in which dialect they are parsed and instantiated and
the way the replacement value is computed. Example:
<tt>^{wlang/active-string}{&#8230;}</tt> (also known as
&#8216;encoding&#8217;) instantiates 1, looking for an encoder qualified
name. Instantiates 2 in the current dialect. Encode 2&#8216;s instantiation
using encoder found in (1)

</dd>
<dt>context</dt><dd>Some rules allow code to be executed in the <em>hosting language</em> (the
definition explicitly announce it by putting <tt>wlang/hosted</tt> in the
corresponding block). When doing so, this code is in fact executed in a
given context that provides the execution semantics. Abstraction
implemented in <a
href="../classes/WLang/Parser/Context.html">WLang::Parser::Context</a>.

</dd>
<dt>hosting language</dt><dd>language (or framework) that executes wlang. In this case, it will be
<tt>ruby</tt>.

</dd>
</dl>

    </div>


   </div>


  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>