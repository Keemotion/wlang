=== Instantiation

The _wlang_ grammar used to write a _template_ is generic and simple: every character stands for itself
(meaning that it is reproduced exactly when the template is instantiated) except <em>tags</em> (and
their associated <em>blocks</em>) that are replaced by the <em>replacement value</em> of the associated
_rule_ (see the glossary for a definition of the italic terms; or simply read on, things should quiclky 
become clear). Consider the following example:
    <html>
      <head>
        <title>${title}</title>
      </head>
      <body>
        <h1>Hello *{authors as who}{${who}}{, } !</h1>
      </body>
    </html>
Assume that we have some instantitation data through the following hash (or something similar, like
a YAML file): 
  {"title" => "Short overview of wlang", "authors" => ["blambeau", "llambeau", "ancailliau"]}
When instantiated this template will produce exactly the same html file except for special tags <tt>${title}</tt>
and <tt>*{whos as who}{${who}}{, }</tt> that will be replaced by <tt>'Short overview of wlang'</tt> and
<tt>'blambeau, llambeau, ancailliau'</tt>, respectively. A lot of tags is available, each of them being 
designed for a specific task: inserting the value of a variable, iterating over collections, including another
file, dynamically loading instantiation data, etc. All of these things are commonly proposed by templating
engines and _wlang_ is one of them ... However, _wlang_ is a bit different as will quickly appear.

Indeed (and maybe surprisingly) _wlang_ can also behave really differently on the same template: 
replacing <tt>${title}</tt> but not <tt>*{..}</tt> or the converse, or not replacing anything, or replacing 
both tags but not <tt>${who}</tt>, etc. All of this is possible in _wlang_. The magic relies under the notion 
of _dialect_, which you need to understand.

=== Dialects

The notion of dialect drives the recognition of tags as well as their replacement during instantiation. 
Dialects are what makes _wlang_ really powerful: if instantiated as being written in the <tt>wlang/xhtml</tt> 
dialect, the template above will give the result mentionned previously. In contrast, if written in 
<tt>wlang/dummy</tt> the template will be reproduced whitout any change (no tag replacement at all). 
This behavior is not hardcoded; it results from the definition of wlang (standard) dialects: <tt>wlang/xhtml</tt> 
define special meanings for <tt>${...}</tt> and <tt>*{...}{...}{...}</tt> while <tt>wlang/dummy</tt> does not.
 
A complete _wlang_ implementation already provides the standard dialects for common tasks: creating html pages, 
building SQL queries, generating code in Ruby or in another language, etc. Each dialect comes with special 
tags that are useful for the task at hand (a tag for back-quoting values is useful for creating SQL queries
but does not really makes sense 
for generating an html page where, in contrast, a tag for encoding entities is probably welcome). Such an 
implementation also allows you to extend standard dialects and to create your own dialect by implementing 
specific tags and rules or by reusing existing ones. Lastlty, the dialect in used during instantiation can be changed 
dynamically  (_explicitly_, by using the <tt>%{dialect/qualified/name}{...}</tt> standard tag and _implicitly_,
when rules parse their blocks).

To learn more about standard dialects and reusable rules, read the 'Rulesets' and 'Dialects' pages of this 
documentation.

=== Grammar

The (abstract) _wlang_ grammar rules what forms a valid template. At first glance, this grammar does not depend on the
dialect that is used for instantiation. It is simple, but comes with some constraints that are explained below:
- block delimiters are '{' and '}' by default; _wlang_ can be configured to use '(' and ')' or '[' and ']' instead. 
  However, block <u>delimiters are template-specific</u>: only one kind of delimiters can be used inside the same template.
- block delimiters <u>must always be paired</u>, even when not used for delimiting blocks. If an opening or closing delimiter 
  is not paired, it must be escaped with a backslash, which will not be reproduced. If you want a backslash to appear before
  a block delimiter in the instantiation result, use a double backslash.
- if a given tag has a special meaning in the current dialect and you don't want it to be replaced by _wlang_ you can escape
  it with a backslash as well (the backslash will not be reproduced).
- some tags (precisely: some rules associated with tags) require multiple blocks (like <tt>*{...}{...}{...}</tt> in 
  <tt>wlang/xhtml</tt> for example, with the third block bein optional). In such a case no character is allowed between 
  the end of a block '}' and the start of the next one '{', not even spaces or
  a carriage return. In other words, multiple blocks (that must be interpreted as such) must touch each others using '}{' precisely, 
  as ilustrated below. If a non-optional block is missing a parse error is raised by the _wlang_ implementation.
      
    *{authors as who}{${who}}{, }    ->    blambeau, llambeau, ancailliau
    *{authors as who}{${who}} {, }   ->    blambeaullambeauancailliau {, }
    *{authors as who} {${who}}{, }   ->    parse error 1:18, missing block 2 in *{...}{...}
  
In addition to these constraints, dialects and the hosting language may impose restrictions on what can be put inside specific
blocks of tags/rules (for example, 'authors as who' is valid as first tag of <tt>*{...}{...}</tt> but not every string is, of course). 
These constraints are not specific to the wlang grammar <em>per se</em> and are explained in the 'Rulesets', 'Dialects' and 'Hosting 
language' pages of this document. 
