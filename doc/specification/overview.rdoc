=== What is _wlang_ designed for?

_wlang_ helps you <b>generating code</b>, in a broad sense. It was originally the templating engine of 
w@w, a proof-of-concept web framework. While more powerful than the original version, the <b>templating 
engine</b> ability of _wlang_ has been kept unchanged. For this reason, generating html code with _wlang_
is probably a bit more mature than generating ruby, java or sql code, to take some examples of what
_wlang_ can do. It is the author opinion that _wlang_ will also become mature quiclky for these tasks
because of its foundations: <b>its engine is generic</b> (in a sense, _wlang_ does not really care about 
what it generates) but is <b>fully and easily configurable</b>. Generation of html files is mature because
_wlang_ has been used a lot for such a job; thus its authors have acquired experience of what is
useful when generating simple as well as complex html files. This experience led us to a mature
configuration of the _wlang_ engine for generating html files, as the following paragraph illustrates
(for people interested in generating code in other languages than html, don't stop your reading here:
the paragraph immediately following contains information for you!)

Consider this file for example, which is completely self-contained. It consists of several parts, some 
of them being structured - the tables for example - while others are not. It also embeds a complete CSS 
stylesheet and some javascript functions. We have not written this file manually, nor do we maintain it 
this way. In fact, this reference document is entirely generated by _wlang_  itself from separated parts 
written mainly in yaml and rdoc files. Also, the cheatsheets given later contains a lot of examples. To 
ensure that all of them are correct, we simply ask _wlang_ to compute them during generation (technically, 
we say that <b>_wlang_ naturally allows metaprogramming</b>). Lastly, if _wlang_ can be used inside a web 
framework, it can also be used as a standalone (commandline) tool for generating single files like this 
one or multiple files, even if all of them are of different nature.

<b>Maybe you are looking for a code generator for another language than html</b> (which one does not really care, 
unless really specific; we call it the <em>target language</em>)?
Don't be affraid by our previous words about _wlang_'s maturity: even in such a case, _wlang_ is your friend. 
Start with an existing dialect (see later about dialects), which will provide basic utilities for starting and try 
to identify common patterns when you use them. Then simply create special shortcuts that are more friendly to 
use than combining several existing utils ... you are on the way of creating your own mature and reusable dialect 
for that target language. In this case, don't forget to share it ...

=== Template and instantiation

The _wlang_ grammar used to write a _template_ is generic and simple: every character stands for itself
(meaning that it is reproduced exactly when the template is instantiated) except <em>tags</em> (and
their associated <em>blocks</em>, enclosed between '{' and '}') that are replaced by what is called the
<em>replacement value</em>. Consider the following example:
    <html>
      <head>
        <title>${title}</title>
      </head>
      <body>
        <h1>Hello *{authors as who}{${who}}{, } !</h1>
      </body>
    </html>
Assume that we have some instantitation data through the following hash (or something similar, like
a YAML file): 
  {"title" => "Short overview of wlang", "authors" => ["blambeau", "llambeau", "ancailliau"]}
When instantiated this template will produce exactly the same html file except for special tags <tt>${title}</tt>
and <tt>*{whos as who}{${who}}{, }</tt> that will be replaced by <tt>'Short overview of wlang'</tt> and
<tt>'blambeau, llambeau, ancailliau'</tt>, respectively. A lot of tags is available, each of them being 
designed for a specific task: inserting the value of a variable, iterating over collections, including another
file, dynamically loading instantiation data, etc. All of these things are commonly proposed by templating
engines and _wlang_ is one of them ... However, _wlang_ is a bit different as will quickly appear.

Indeed (and maybe surprisingly) _wlang_ can also behave really differently on the same template: 
replacing <tt>${title}</tt> but not <tt>*{...}</tt> or the converse, or not replacing anything, or replacing 
both tags but not <tt>${who}</tt>, etc. All of this is possible in _wlang_. The magic relies under the notion 
of _dialect_, which you need to understand.

=== Dialects and Rulesets

The notion of dialect drives the recognition of tags as well as their replacement during instantiation. 
Dialects are what makes _wlang_ really powerful: if instantiated as being written in the <tt>wlang/xhtml</tt> 
dialect, the template above will give the result mentionned previously. In contrast, if written in 
<tt>wlang/dummy</tt> the template will be reproduced whitout any change (no tag replacement at all). 
This behavior is not hardcoded; it results from the definition of wlang (standard) dialects: <tt>wlang/xhtml</tt> 
define special meanings for <tt>${...}</tt> and <tt>*{...}{...}{...}</tt> while <tt>wlang/dummy</tt> does not.

The replacement of a given _tag_ during instantiation is computed by what we call the _rule_ attached to the tag
(keeping rules and tags as different concepts leads to another feature of _wlang_: you can reuse rule 
implementations and attach them to other tags than those proposed). A dialect comes with a set of (tag, rule)
pairs that determine its replacement behavior. Such a set is called a _ruleset_; for easier reuse, standard 
rulesets are already implemented. A dialect is a packaging of standard rulesets (and maybe implements specific 
tag/rule pairs) designed for generating code in a given target language.
 
A complete _wlang_ implementation already provides standard dialects for common tasks: creating html pages, 
building SQL queries, generating code in Ruby or in another language, etc. Each dialect comes with special 
tags that are useful for the task at hand (a tag for back-quoting values is useful for creating SQL queries
but does not really makes sense 
for generating an html page where, in contrast, a tag for encoding entities is probably welcome). Such an 
implementation also allows you to extend standard dialects and to create your own dialect by implementing 
specific tags and rules or by reusing existing ones. Lastlty, the dialect in used during instantiation can be changed 
dynamically  (_explicitly_, by using the <tt>%{dialect/qualified/name}{...}</tt> standard tag and _implicitly_,
when rules parse their blocks).

To learn more about standard dialects and reusable rules, read the 'Dialects' and 'Rulesets' pages of this 
documentation.

=== Grammar

The (abstract) _wlang_ grammar rules what forms a valid template. At first glance, this grammar does not depend on the
dialect that is used for instantiation. It is simple, but comes with some constraints that are explained below:
- block delimiters are '{' and '}' by default; _wlang_ can be configured to use '(' and ')' or '[' and ']' instead. 
  However, block <b>delimiters are template-specific</b>: only one kind of delimiters can be used inside the same template.
- block delimiters <b>must always be paired</b>, even when not used for delimiting blocks. If an opening or closing delimiter 
  is not paired, it must be escaped with a backslash, which will not be reproduced. If you want a backslash to appear before
  a block delimiter in the instantiation result, use a double backslash.
- if a given tag has a special meaning in the current dialect and you don't want it to be replaced by _wlang_ you can escape
  it with a backslash as well (the backslash will not be reproduced).
- some tags (precisely: some rules associated with tags) require multiple blocks (like <tt>*{...}{...}{...}</tt> in 
  <tt>wlang/xhtml</tt> for example, with the third block bein optional). In such a case no character is allowed between 
  the end of a block '}' and the start of the next one '{', not even spaces or
  a carriage return. In other words, multiple blocks (that must be interpreted as such) must touch each others using '}{' precisely, 
  as ilustrated below. If a non-optional block is missing a parse error is raised by the _wlang_ implementation.
      
    *{authors as who}{${who}}{, }    ->    blambeau, llambeau, ancailliau
    *{authors as who}{${who}} {, }   ->    blambeaullambeauancailliau {, }
    *{authors as who} {${who}}{, }   ->    parse error 1:18, missing block 2 in *{...}{...}
  
In addition to these constraints, dialects and the hosting language may impose restrictions on what can be put inside specific
blocks of tags/rules (for example, 'authors as who' is valid as first tag of <tt>*{...}{...}</tt> but not every string is, of course). 
These constraints are not specific to the wlang grammar <em>per se</em> and are explained in the 'Rulesets', 'Dialects' and 'Hosting 
language' pages of this document. 
