---
title: WLang specification
version: 0.0.7
what: |-
  WLang is a a reusable and extensible <em>code generator</em>, also known as a 
  <em>templating engine</em>. Motivation for it can be found at http://www.revision-zero.org/wlang.
  The current file provides its specification. Accepted tags, standard dialects and the like can be 
  accessed through the menu (top right). Below is the terminology used here.
grammar: |-
  The _wlang_ grammar used to write templates is generic and simple: every character stands for itself
  (meaning that it will be reproduced as such when the template is instantiated) except <em>tags</em> (and
  their associated <em>blocks</em>) that are replaced by the <em>replacement value</em> of the associated
  _rule_. Consider the following example:
      <html>
        <head>
          <title>${title}</title>
        </head>
        <body>
          <h1>Hello *{authors as who}{${who}}{, } !</h1>
        </body>
      </html>
  When instantiated, this template will produce exactly the same html file except for special tags <tt>${title}</tt>
  and <tt>*{whos as who}{${who}}{, }</tt> that will be replaced by something else (typically the value of the 
  <tt>title</tt> variable for the former and comma separated names of the <tt>authors</tt> for the second, assuming
  that <tt>authors</tt> is an array variable).
  
  The only tricky thing in _wlang_ is the notion of dialect, which drives the  
terminology:
  - term: template 
    definition: |-
      Source code respecting the wlang grammar, and attached to a given <em>wlang 
      dialect</em>.
    example: |-
      <tt>Hello ${name}</tt>
  - term: dialect
    definition: |-
      Basically, <em>dialect</em> is used as a synonym for (programming) <em>language</em>.
      However _wlang_ uses a tree of dialects, allowing specializations: <tt>sql/sybase</tt>
      for example is the qualified name of a sub-dialect 'sybase' of the 'sql' dialect. 
      Dialects come with associated _encoders_.
    example: |-
      <tt>sql/sybase</tt>
  - term: wlang dialect
    definition: |-
      When we talk about a <em>wlang dialect</em>, we are actually refering to some 
      specialization of the wlang tag-based grammar: <tt>wlang/xhtml</tt> for example
      is the templating language _wlang_ proposes to generate xhtml pages. An 
      example of source code in that dialect has been shown before.
      In addition to its encoders a <em>wlang dialect</em> comes with its sets of _tags_ 
      and associated _rules_.
    example: |-
      <tt>wlang/xhtml</tt>
  - term: encoder
    definition: |-
      Text transformation (algorithm) applying some encoding conventions of a portion
      of a the target language generated by a dialect. HTML entities-encoding, SQL's back-quoting 
      are examples of encoders. Encoders are accessible through their qualified name (dialect/encoder).
    example: |-
      <tt>xhtml/entities-encoding</tt><br/><tt>sql/single-quoting</tt>
  - term: ruleset
    definition: |-
      Reusable set of <em>tags</em> associated to <em>rule</em>s.
    example: |-
      <tt>Imperative ruleset</tt><br/><tt>Encoding rulset</tt>
  - term: wlang tag
    definition: |-
      Special tags in the template, starting with wlang symbols and a number of wlang 
      blocks. A tag is associated with a wlang rule. 
    example: |-
      <tt>${...}</tt><br/><tt>?{...}{...}{...}</tt>
  - term: rule
    definition: |-
      Transformation semantics of a given <em>tag</em>. When wlang instantiates a
      template it simply replaces <em>wlang tags</em> by some <em>replacement value</em>
      (which is always a string). This value is computed by the rule attached to 
      the tag. Rule definition (see Rulesets tab on top of the page)
      explicitly describes the number of blocks it expects, in which dialect they 
      are parsed and instantiated and the way the replacement value is computed.
    example: |-
      <tt>^{wlang/active-string}{...}</tt><br/>
      Instanciates #1, looking for an encoder qualified name. Instanciates #2 in 
      the current dialect. Encode #2's instantiation using encoder found in (#1)
      and return the result as replacement value.
  - term: context
    definition: |-  
      Some rules allow code to be executed in the <em>hosting language</em> (the 
      definition explicitly announce it by putting <tt>wlang/hosted</tt> in the corresponding
      block). When doing so, this code is in fact executed in a given context that 
      provides the execution semantics.
  - term: hosting language
    definition: |-
      language (or framework) that executes wlang. 
    example: |-
      ruby
rulesets: 
  - name: Basic 
    examples:
      - ["wlang/active-string", "Hello !{name}",                       "Hello O'Neil"]
      - ["wlang/active-string", "Hello %{wlang/dummy}{!{name}}",       "Hello !{name}"]
      - ["wlang/dummy",         "Hello %{wlang/dummy}{!{name}}",       "Hello %{wlang/dummy}{!{name}}"]
      - ["wlang/active-string", "Hello ^{plain-text/upcase}{!{name}}", "Hello O'NEIL"]
    rules:
      # !{wlang/hosted}
      - name:      "execution"
        symbol:    "!"
        signature: "!{wlang/hosted}"
        definition: |-
          Instantiates #1, looking for an expression of the hosting language. Evaluates it, 
          looking for any object. Converts it to a string (using to_s for example if Ruby is
          the hosting language) and returns the result as replacement value.
      
      # %{wlang/active-string}{...}
      - name:      "modulation"
        symbol:    "%"
        signature: "%{wlang/active-string}{...}"
        definition: |-
          Instantiates #1, looking for a dialect qualified name. Instantiates #2 
          according to the rules defined by that dialect and returns the #2's 
          instantiation as replacement value.
      
      # ^{wlang/active-string}{...}
      - name:      "encoding"
        symbol:    "^"
        signature: "^{wlang/active-string}{...}"
        definition: |-
          Instantiates #1, looking for an encoder qualified name. Instantiates #2 in 
          the current dialect. Encode #2's instantiation using encoder found in (#1) and
          returns encoding as replacement value.
      
      # ${wlang/hosted}
      - name:      "injection"
        symbol:    "$"
        signature: "${wlang/hosted}"
        definition: Same semantics as execution so far.
      
      # +{wlang/hosted}
      - name:      "inclusion"
        symbol:    "+"
        signature: "+{wlang/hosted}"
        definition: Same semantics as execution so far.

  - name: Encoding
    examples:
      - ["wlang/xhtml", "Hello &{name}",                       "Hello name"]
      - ["wlang/xhtml", "Hello &{<script>}",                   "Hello &lt;script&gt;"]
      - ["wlang/xhtml", "Hello &;{<script>}",                  "Hello &lt;script&gt;"]
      - ["wlang/ruby",  "puts 'Hello &'{name}'",               "puts 'Hello name'"]
      - ["wlang/ruby",  "puts 'Hello &'{!{name}}'",            "puts 'Hello O\'Neil'"]
      - ["wlang/ruby",  "puts 'Hello ' << '{name}'",           "puts 'Hello ' << 'O\'Neil'"]
      - ["wlang/sql",   "... WHERE name='{name}'",             "... WHERE name='O\'Neil'"]
      - ["wlang/sql/sybase",  "... WHERE name='{name}'",       "... WHERE name='O''Neil'"]
    rules:
      # &{...}
      - name:       "main-encoding"
        symbol:     "&"
        signature:  "&{...}"
        definition: "<tt>^{+{@parser.current_dialect}/main-encoding}{#1}</tt>"
    
      # &;{...}
      - name:       "entities-encoding"
        symbol:     "&;"
        signature:  "&;{...}"
        definition: "<tt>^{+{@parser.current_dialect}/entities-encoding}{#1}</tt>"
    
      # &'{...}
      - name:       "single-quoting"
        symbol:     "&'"
        signature:  "&'{...}"
        definition: "<tt>^{+{@parser.current_dialect}/single-quoting}{#1}</tt>"
    
      # &;{...}
      - name:       "double-quoting"
        symbol:     '&"'
        signature:  '&"{...}'
        definition: "<tt>^{+{@parser.current_dialect}/double-quoting}{#1}</tt>"
    
      # ${wlang/hosted}
      - name:      "injection"
        symbol:    "$"
        signature: "${wlang/hosted}"
        definition: "<tt>&{+{#1}}</tt>"
    
      # '{wlang/hosted}
      - name:      "single-quoted"
        symbol:    "'"
        signature: "'{wlang/hosted}"
        definition: |-
          <tt>'&'{+{#1}}</tt> (first single quote is kept in the result)
    
      # "{wlang/hosted}
      - name:      "double-quoted"
        symbol:    '"'
        signature: '"{wlang/hosted}'
        definition: |-
          <tt>"&"{+{#1}}</tt> (first double quote is kept in the result)
        
  - name: Imperative
    examples:
      - ["wlang/*", '?{true}{then}{else}',                         'then']
      - ["wlang/*", '?{/th/ =~ "not tat"}{then}{else}',            'else']
      - ["wlang/*", '?{authors.include? "blambeau"}{yes}{no}',    'yes']
      - ["wlang/*", '[*{authors as a}{"{a}"}{, }]', '["blambeau", "llambeau", "ancailliau"]']
    rules:
      # ?{wlang/hosted}{...}{...}
      - name:      "conditional<br/>(third block is optional)"
        symbol:    "?"
        signature: "?{wlang/hosted}{...}{...}"
        definition: |-
          Instantiates #1, looking for an expression in the hosting language. 
          Evaluates it, looking for a boolean value (according to boolean semantics 
          of the hosting language). If true, instantiates #2, otherwise instantiates 
          #3 if present, returning instantiation as replacement value.
    
      # *{wlang/hosted as x}{...}{...}
      - name:      "enumeration<br/>(third block is optional)"
        symbol:    "*"
        signature: "*{wlang/hosted as x}{...}{...}"
        definition: |-
          Instantiates #1, looking for an expression in the hosting language. Evaluates 
          it, looking for an enumerable. Iterates all its elements, instantiating #2 for 
          each of them (the iterated value is set under name x in the scope). If #3 is 
          present, it is instantiated between elements. Replacement is the concatenation
          of all these instantiations.

  - name: Context
    examples:
      - ["wlang/*", '={name as n}{Hello +{n}}',                      "Hello O'Neil"]
      - ["wlang/*", '={name as n}Hello +{n}',                        "Hello O'Neil"]
      - ["wlang/*", '#={name}{blambeau}{Hello +{name}} and +{name}', "Hello blambeau and O'Neil"]
      - ["wlang/*", '#={name}{blambeau}Hello +{name} and +{name}',   "Hello blambeau and blambeau"]
      - ["wlang/*", '={author as name}{Hello +{name}} and +{name}', "Hello blambeau and O'Neil"]
      - ["wlang/*", '={author as name}Hello +{name} and +{name}',   "Hello blambeau and blambeau"]
      - ["wlang/*", '%={wlang/dummy as hello}{Hello +{name}}{+{hello}}', "Hello +{name}"]
      - ["wlang/*", '^={plain-text/upcase as name}{+{author}}{Hello +{name}} and +{name}', "Hello BLAMBEAU and O'Neil"]
      - ["wlang/*", '^={plain-text/upcase as name}{+{author}}Hello +{name} and +{name}', "Hello BLAMBEAU and BLAMBEAU"]
      
    rules: 
      # ={wlang/hosted as x}{...}
      - name:      "assignment<br/>(second block is optional)"
        symbol:    "="
        signature: "={wlang/hosted as x}{...}"
        definition: |-
            Instantiates #1, looking for an expression in the hosting language. Evaluates 
            it, looking for any object. Without second block, expands the current scope with 
            'x' being bound to evaluation result. Otherwise, branches the current scope for
            the second block instantiation only and bind 'x' the same way (i.e. x will not be 
            available outside the second block). Returns an empty string as replacement value.
      # #={wlang/active-string}{...}{...}
      - name:      "block-assignment<br/>(third block is optional)"
        symbol:    "="
        signature: "#={wlang/active-string}{...}{...}"
        definition: |-
          Instantiates #1, looking for a variable name (say 'x'). Instantiates #2 in the current 
          dialect. Without third block, expands the current scope with 'x' being bound to #2's 
          instantiation. Otherwise, branches the current scope for the third block instantiation 
          only and binds 'x' the same way (i.e. x will not be available outside the third block). 
          Returns an empty string as replacement value.
      # %={wlang/active-string as x}{...}{...}
      - name:      "modulo-assignment<br/>(second block is optional)"
        symbol:    "%="
        signature: "%={wlang/active-string as x}{...}{...}"
        definition: |-
            Instantiates #1, looking for a dialect qualified name. Instantiates #2 according 
            to the rules defined by that dialect. Without third block, expands the current 
            scope with 'x' being bound to #2's instantiation. Otherwise, branches the current 
            scope for the third block instantiation only and binds 'x' the same way (i.e. x will 
            not be available outside the third block). Returns an empty string as replacement 
            value.
      # ^={wlang/active-string as x}{...}{...}
      - name:      "encoding-assignment<br/>(second block is optional)"
        symbol:    "^="
        signature: "^={wlang/active-string as x}{...}{...}"
        definition: |-
            Instantiates #1, looking for an encoder qualified name. Instantiates #2 in 
            the current dialect. Encode #2's instantiation using encoder found in (#1).
            Without third block, expands the current scope with 'x' being bound to #2's encoding. 
            Otherwise, branches the current scope for the third block instantiation only and binds 
            'x' the same way (i.e. x will not be available outside the third block). Returns an 
            empty string as replacement value.<br/>

  - name: Buffering
    rules:
      # <<{wlang/uri}
      - name:      "input"
        symbol:    "<<"
        signature: "<<{wlang/uri}"
        definition: |-
          Instantiates #1, looking for an uri. Returns the text content of the found 
          uri (#1) as replacement value.
      # >>{wlang/uri}
      - name:      "output"
        symbol:    ">>"
        signature: ">>{wlang/uri}{...}"
        definition: |-
          Instantiates #1, looking for an uri. Instantiates #2 in the current dialect,
          using file found in #1 as output buffer. Returns an empty string as replacement
          value
symbols:
  - name: exclamation mark
    symbol: '!'
    meaning: execution
    remark: should never be overrided as single
  - name: 'caret/circumflex'
    symbol: '^'
    meaning: explicit encoding
    remark: should never be overrided as single
  - name: percent
    symbol: '%'
    meaning: modulation
    remark: should never be overrided as single
  - name: double quote
    symbol: '"'
    meaning: double-quoting
  - name: dollar
    symbol: '$'
    meaning: 'main-encoding'
  - name: ampersand
    symbol: '&'
    meaning: encoding
  - name: single quote
    symbol: "'"
    meaning: single-quoting
  - name: asterisk
    symbol: '*'
    meaning: iteration
  - name: plus
    symbol: '+'
    meaning: inclusion
  - name: question mark
    symbol: '?'
    meaning: condition
  - name: at symbol
    symbol: '@'
    meaning: linking
  - name: tilde
    symbol: '~'
    meaning: matching
  - name: number sign  
    symbol: '#'
  - name: comma
    symbol: ','
  - name: minus (dash)
    symbol: '-'
  - name: dot
    symbol: '.'
  - name: forward slash
    symbol: '/'
  - name: colon
    symbol: ':'
  - name: 'semi-colon'
    symbol: ';'
  - name: equal sign
    symbol: '='
  - name: less than
    symbol: '<'
  - name: greater than
    symbol: '>'
  - name: vertical bar
    symbol: '|'
  - name: underscore
    symbol: '_'
    remark: cannot be used as tag symbol; reserved for escaping in future versions
  - name: back slash
    symbol: \
    remark: cannot be used as tag symbol; reserved for escaping in current version
  - name: left parenthesis
    symbol: '('
    remark: cannot be used as tag symbol; reserved for block delimiter 
  - name: right parenthesis
    symbol: ')'
    remark: cannot be used as tag symbol; reserved for block delimiter 
  - name: left bracket
    symbol: '['
    remark: cannot be used as tag symbol; reserved for block delimiter 
  - name: right bracket
    symbol: ']'
    remark: cannot be used as tag symbol; reserved for block delimiter 
  - name: left brace
    symbol: '{'
    remark: cannot be used as tag symbol; reserved for block delimiter 
  - name: right brace
    symbol: '}'
    remark: cannot be used as tag symbol; reserved for block delimiter 
          
    
    