--- 
title: WLang specification
version: 0.0.7
what: WLang is a a reusable and extensible <em>code generator</em>, also known as a <em>templating engine</em>
rulesets: 
  - name: Basic 
    rules:
      # !{wlang/hosted}
      - name:      "execution"
        symbol:    "!"
        signature: "!{wlang/hosted}"
        definition: |-
          Instanciates #1, looking for a ruby expression. Evaluates it, looking for 
          any object. Invokes to_s on it and returns the result as replacement value.
      
      # %{wlang/active-string}{...}
      - name:      "modulation"
        symbol:    "%"
        signature: "%{wlang/active-string}{...}"
        definition: |-
          Instanciates #1, looking for a dialect qualified name. Instantiates #2 
          according to the rules defined by that dialect and returns the #2's 
          instantiation as replacement value.
      
      # ^{wlang/active-string}{...}
      - name:      "encoding"
        symbol:    "^"
        signature: "^{wlang/active-string}{...}"
        definition: |-
          Instanciates #1, looking for an encoder qualified name. Instanciates #2 in 
          the current dialect. Encode #2's instantiation using encoder found in (#1)
      
      # ${wlang/hosted}
      - name:      "injection"
        symbol:    "$"
        signature: "${wlang/hosted}"
        definition: Same semantics as execution so far.
      
      # +{wlang/hosted}
      - name:      "inclusion"
        symbol:    "+"
        signature: "+{wlang/hosted}"
        definition: Same semantics as execution so far.

  - name: Encoding
    rules:
      # &{...}
      - name:       "main-encoding"
        symbol:     "&"
        signature:  "&{...}"
        definition: "<tt>^{+{@parser.current_dialect}/main-encoding}{#2}</tt>"
    
      # &;{...}
      - name:       "entities-encoding"
        symbol:     "&;"
        signature:  "&;{...}"
        definition: "<tt>^{+{@parser.current_dialect}/entities-encoding}{#2}</tt>"
    
      # &'{...}
      - name:       "single-quoting"
        symbol:     "&'"
        signature:  "&'{...}"
        definition: "<tt>^{+{@parser.current_dialect}/single-quoting}{#2}</tt>"
    
      # &;{...}
      - name:       "double-quoting"
        symbol:     '&"'
        signature:  '&"{...}'
        definition: "<tt>^{+{@parser.current_dialect}/double-quoting}{#2}</tt>"
    
      # ${wlang/hosted}
      - name:      "injection"
        symbol:    "$"
        signature: "${wlang/hosted}"
        definition: "<tt>&{+{#1}}</tt>"
    
      # '{wlang/hosted}
      - name:      "single-quoted"
        symbol:    "'"
        signature: "'{wlang/hosted}"
        definition: "<tt>'&'{+{#1}}</tt>"
    
      # "{wlang/hosted}
      - name:      "double-quoted"
        symbol:    '"'
        signature: '"{wlang/hosted}'
        definition: '<tt>"&"{+{#1}}</tt>'
        
  - name: Imperative
    rules:
      # ?{wlang/hosted}{...}{...}
      - name:      "conditional"
        symbol:    "?"
        signature: "?{wlang/hosted}{...}{...}"
        definition: |-
          <b>(third block is optional)</b> Instanciates #1, looking for an expression 
          in the hosting language. Evaluates it, looking for a boolean value (according 
          to boolean semantics of the hosting language). If true, instanciates #2, 
          otherwise instanciates #3 if present.
    
      # *{wlang/hosted}{...}{...}
      - name:      "enumeration"
        symbol:    "*"
        signature: "*{wlang/hosted}{...}{...}"
        definition: |-
          <b>(third block is optional)</b> Instanciates #1, looking for an expression in 
          the hosting language. Evaluates it, looking for an enumerable. Iterates 
          all its elements, instanciating #2 for each of them (the iterated value is 
          set under name x in the scope). If #3 is present, it is instanciated between
          elements.

  - name: Buffering
    rules:
      # <<{wlang/uri}
      - name:      "input"
        symbol:    "<<"
        signature: "<<{wlang/uri}"
        definition: |-
          Instanciates #1, looking for an uri. Returns the text content of the found 
          uri (#1).
    
    