---
title: WLang specification
version: 0.0.7
what: |-
  WLang is a a reusable and extensible <em>code generator</em>, also known as a 
  <em>templating engine</em>.
rulesets: 
  - name: Basic 
    examples:
      - ["wlang/active-string", "Hello !{name}",                       "Hello O'Neil"]
      - ["wlang/active-string", "Hello %{wlang/dummy}{!{name}}",       "Hello !{name}"]
      - ["wlang/dummy",         "Hello %{wlang/dummy}{!{name}}",       "Hello %{wlang/dummy}{!{name}}"]
      - ["wlang/active-string", "Hello ^{plain-text/upcase}{!{name}}", "Hello O'NEIL"]
    rules:
      # !{wlang/hosted}
      - name:      "execution"
        symbol:    "!"
        signature: "!{wlang/hosted}"
        definition: |-
          Instantiates #1, looking for an expression of the hosting language. Evaluates it, 
          looking for any object. Converts it to a string (using to_s for example if Ruby is
          the hosting language) and returns the result as replacement value.
      
      # %{wlang/active-string}{...}
      - name:      "modulation"
        symbol:    "%"
        signature: "%{wlang/active-string}{...}"
        definition: |-
          Instantiates #1, looking for a dialect qualified name. Instantiates #2 
          according to the rules defined by that dialect and returns the #2's 
          instantiation as replacement value.
      
      # ^{wlang/active-string}{...}
      - name:      "encoding"
        symbol:    "^"
        signature: "^{wlang/active-string}{...}"
        definition: |-
          Instantiates #1, looking for an encoder qualified name. Instantiates #2 in 
          the current dialect. Encode #2's instantiation using encoder found in (#1) and
          returns encoding as replacement value.
      
      # ${wlang/hosted}
      - name:      "injection"
        symbol:    "$"
        signature: "${wlang/hosted}"
        definition: Same semantics as execution so far.
      
      # +{wlang/hosted}
      - name:      "inclusion"
        symbol:    "+"
        signature: "+{wlang/hosted}"
        definition: Same semantics as execution so far.

  - name: Encoding
    examples:
      - ["wlang/xhtml", "Hello &{name}",                       "Hello name"]
      - ["wlang/xhtml", "Hello &{<script>}",                   "Hello &lt;script&gt;"]
      - ["wlang/xhtml", "Hello &;{<script>}",                  "Hello &lt;script&gt;"]
      - ["wlang/ruby",  "puts 'Hello &'{name}'",               "puts 'Hello name'"]
      - ["wlang/ruby",  "puts 'Hello &'{!{name}}'",            "puts 'Hello O\'Neil'"]
      - ["wlang/ruby",  "puts 'Hello ' << '{name}'",           "puts 'Hello ' << 'O\'Neil'"]
      - ["wlang/sql",   "... WHERE name='{name}'",             "... WHERE name='O\'Neil'"]
      - ["wlang/sql/sybase",  "... WHERE name='{name}'",       "... WHERE name='O''Neil'"]
    rules:
      # &{...}
      - name:       "main-encoding"
        symbol:     "&"
        signature:  "&{...}"
        definition: "<tt>^{+{@parser.current_dialect}/main-encoding}{#1}</tt>"
    
      # &;{...}
      - name:       "entities-encoding"
        symbol:     "&;"
        signature:  "&;{...}"
        definition: "<tt>^{+{@parser.current_dialect}/entities-encoding}{#1}</tt>"
    
      # &'{...}
      - name:       "single-quoting"
        symbol:     "&'"
        signature:  "&'{...}"
        definition: "<tt>^{+{@parser.current_dialect}/single-quoting}{#1}</tt>"
    
      # &;{...}
      - name:       "double-quoting"
        symbol:     '&"'
        signature:  '&"{...}'
        definition: "<tt>^{+{@parser.current_dialect}/double-quoting}{#1}</tt>"
    
      # ${wlang/hosted}
      - name:      "injection"
        symbol:    "$"
        signature: "${wlang/hosted}"
        definition: "<tt>&{+{#1}}</tt>"
    
      # '{wlang/hosted}
      - name:      "single-quoted"
        symbol:    "'"
        signature: "'{wlang/hosted}"
        definition: |-
          <tt>'&'{+{#1}}</tt> (first single quote is kept in the result)
    
      # "{wlang/hosted}
      - name:      "double-quoted"
        symbol:    '"'
        signature: '"{wlang/hosted}'
        definition: |-
          <tt>"&"{+{#1}}</tt> (first double quote is kept in the result)
        
  - name: Imperative
    examples:
      - ["wlang/*", '?{true}{then}{else}',                         'then']
      - ["wlang/*", '?{/th/ =~ "not tat"}{then}{else}',            'else']
      - ["wlang/*", '?{authors.include? "blambeau"}{yes}{no}',    'yes']
      - ["wlang/*", '[*{authors as a}{"{a}"}{, }]', '["blambeau", "llambeau", "ancailliau"]']
    rules:
      # ?{wlang/hosted}{...}{...}
      - name:      "conditional<br/>(third block is optional)"
        symbol:    "?"
        signature: "?{wlang/hosted}{...}{...}"
        definition: |-
          Instantiates #1, looking for an expression in the hosting language. 
          Evaluates it, looking for a boolean value (according to boolean semantics 
          of the hosting language). If true, instantiates #2, otherwise instantiates 
          #3 if present, returning instantiation as replacement value.
    
      # *{wlang/hosted as x}{...}{...}
      - name:      "enumeration<br/>(third block is optional)"
        symbol:    "*"
        signature: "*{wlang/hosted as x}{...}{...}"
        definition: |-
          Instantiates #1, looking for an expression in the hosting language. Evaluates 
          it, looking for an enumerable. Iterates all its elements, instantiating #2 for 
          each of them (the iterated value is set under name x in the scope). If #3 is 
          present, it is instantiated between elements. Replacement is the concatenation
          of all these instantiations.

  - name: Context
    examples:
      - ["wlang/*", '={name as n}{Hello +{n}}',                     "Hello O'Neil"]
      - ["wlang/*", '={name as n}Hello +{n}',                       "Hello O'Neil"]
      - ["wlang/*", '={author as name}{Hello +{name}} and +{name}', "Hello blambeau and O'Neil"]
      - ["wlang/*", '={author as name}Hello +{name} and +{name}',   "Hello blambeau and blambeau"]
      - ["wlang/*", '%={hello}{Hello +{name}}{+{hello}}',           "Hello O'Neil"]
      - ["wlang/*", '%={wlang/dummy as hello}{Hello +{name}}{+{hello}}', "Hello +{name}"]
      
    rules: 
      # ={wlang/hosted as x}{...}
      - name:      "assignment<br/>(second block is optional)"
        symbol:    "="
        signature: "={wlang/hosted as x}{...}"
        definition: |-
            Instantiates #1, looking for an expression in the hosting language. Evaluates 
            it, looking for any object. Without second block, expands the current scope with 
            'x' being bound to evaluation result. Otherwise, branches the current scope for
            the second block instantiation only and bind 'x' the same way (i.e. x will not be 
            available outside the second block). Returns an empty string as replacement value.
      # %={wlang/active-string as x}{...}{...}
      - name:      "modulo-assignment<br/>(second block is optional)"
        symbol:    "%="
        signature: "%={wlang/active-string as x}{...}{...}"
        definition: |-
            Instantiates #1, looking for a dialect qualified name. Instantiates #2 according 
            to the rules defined by that dialect. Without third block, expands the current 
            scope with 'x' being bound to #2's instantiation. Otherwise, branches the current 
            scope for the third block instantiation only and bind 'x' the same way (i.e. x will 
            not be available outside the third block). Returns an empty string as replacement 
            value.<br/>
            This rule also accepts a variant allowing the dialect qualified name to be
            omitted (first block contains the variable name only). In this case, the second block
            is instantiated in the current dialect.
      # ^={wlang/active-string as x}{...}{...}
      - name:      "encoding-assignment<br/>(second block is optional)"
        symbol:    "^="
        signature: "^={wlang/active-string as x}{...}{...}"
        definition: |-
            Instantiates #1, looking for an encoder qualified name. Instantiates #2 in 
            the current dialect. Encode #2's instantiation using encoder found in (#1).
            Without third block, expands the current scope with 'x' being bound to #2's encoding. 
            Otherwise, branches the current scope for the third block instantiation only and bind 
            'x' the same way (i.e. x will not be available outside the third block). Returns an 
            empty string as replacement value.<br/>

  - name: Buffering
    rules:
      # <<{wlang/uri}
      - name:      "input"
        symbol:    "<<"
        signature: "<<{wlang/uri}"
        definition: |-
          Instantiates #1, looking for an uri. Returns the text content of the found 
          uri (#1) as replacement value.
      # >>{wlang/uri}
      - name:      "output"
        symbol:    ">>"
        signature: ">>{wlang/uri}{...}"
        definition: |-
          Instantiates #1, looking for an uri. Instantiates #2 in the current dialect,
          using file found in #1 as output buffer. Returns an empty string as replacement
          value
          
    
    