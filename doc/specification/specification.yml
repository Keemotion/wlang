---
title: WLang
version: 0.0.7
what: |-
  WLang is a a reusable and extensible <em>code generator</em>, also known as a 
  <em>templating engine</em>. Motivation for it can be found at http://www.revision-zero.org/wlang.
  The current file provides its specification. Accepted tags, standard dialects and the like can be 
  accessed through the menu (top right). Below is the terminology used here.
overview: |-
  === Instantiation
  
  The _wlang_ grammar used to write templates is generic and simple: every character stands for itself
  (meaning that it is reproduced exactly when the template is instantiated) except <em>tags</em> (and
  their associated <em>blocks</em>) that are replaced by the <em>replacement value</em> of the associated
  _rule_. Consider the following example:
      <html>
        <head>
          <title>${title}</title>
        </head>
        <body>
          <h1>Hello *{authors as who}{${who}}{, } !</h1>
        </body>
      </html>
  Assume that we have some instantitation data through the following hash: 
    {"title" => "Short overview of wlang", "authors" => ["blambeau", "llambeau", "ancailliau"]}
  When instantiated this template will produce exactly the same html file except for special tags <tt>${title}</tt>
  and <tt>*{whos as who}{${who}}{, }</tt> that will be replaced by <tt>'Short overview of wlang'</tt> and
  <tt>'blambeau, llambeau, ancailliau'</tt>, respectively. Maybe surprisingly _wlang_ can also behave
  really differently on the same template: replacing <tt>${title}</tt> but not <tt>*{..}</tt> or the  
  converse, or not replacing anything, or replacing both tags but not <tt>${who}</tt>, etc. All of this
  is possible in _wlang_. The magic relies under the notion of _dialect_, which you need to understand.
  
  === Dialects
  
  The notion of dialect drives the recognition of tags as well as their replacement during instantiation. 
  Dialects are what makes _wlang_ really powerful: if instantiated as being written in the <tt>wlang/xhtml</tt> 
  dialect, the template above will give the result mentionned previously. In contrast, if written in 
  <tt>wlang/dummy</tt> the template will be reproduced whitout any change (no replacement of tags at all). 
  This behavior is not hardcoded; it results from the definition of wlang (standard) dialects: <tt>wlang/xhtml</tt> 
  define special meanings for <tt>${...}</tt> and <tt>*{...}{...}{...}</tt> while <tt>wlang/dummy</tt> does not.
   
  A complete _wlang_ implementation already provides the standard dialects for common tasks: creating html pages, 
  building SQL queries, generating code in Ruby or in another language, etc. Each of them installs special tags that 
  are useful for the task 
  at hand (a tag for back-quoting values is useful for SQL, but does not really makes sense for generating html for 
  example).  Such an implementation also allows you to extend standard dialects, create your own by implementing 
  specific tags and rules or by reusing existing ones. Lastlty, the dialect in used during instantiation can be changed 
  dynamically  (_explicitly_, by using the <tt>%{dialect/qualified/name}{...}</tt> standard tag and _implicitly_,
  when rules parse their blocks).
  
  To learn more about standard dialects and reusable rules, read the 'Rulesets' and 'Dialects' pages of this 
  documentation.
  
  === Grammar
  
  The (abstract) _wlang_ grammar rules what forms a valid template. At first glance, this grammar does not depend on the
  dialect that is used for instantiation. It is simple, but comes with some constraints that are explained below:
  - block delimiters are '{' and '}' by default; _wlang_ can be configured to use '(' and ')' or '[' and ']' instead. 
    However, block <u>delimiters are template-specific</u>: only one kind of delimiters can be used inside the same template.
  - block delimiters <u>must always be paired</u>, even when not used for delimiting blocks. If an opening or closing delimiter 
    is not paired, it must be escaped with a backslash, which will not be reproduced. If you want a backslash to appear before
    a block delimiter in the instantiation result, use a double backslash.
  - if a given tag has a special meaning in the current dialect and you don't want it to be replaced by _wlang_ you can escape
    it with a backslash as well (the backslash will not be reproduced).
  - some tags (precisely: some rules associated with tags) require multiple blocks (like <tt>*{...}{...}{...}</tt> in <tt>wlang/xhtml</tt> 
    for example), some of them being optional as specified in the associated rule (in the example the third block is optional).
    In such a case no character is allowed between the end of a block '}' and the start of the next one '{', not even spaces or
    a carriage return. In other words, multiple blocks (that must be interpreted as such) must touch each others using '}{' precisely, 
    as ilustrated below. If a non-optional block is missing a parse error is raised by the _wlang_ implementation.
        
      *{authors as who}{${who}}{, }    ->    blambeau, llambeau, ancailliau
      *{authors as who}{${who}} {, }   ->    blambeaullambeauancailliau {, }
      *{authors as who} {${who}}{, }   ->    parse error 1:18, missing block 2 in *{...}{...}
    
  In addition to these constraints, dialects and the hosting language may impose restrictions on what can be put inside specific
  blocks of tags/rules (for example, 'authors as who' is valid as first tag of <tt>*{...}{...}</tt> but not every string is, of course). 
  These constraints are not specific to the wlang grammar <em>per se</em> and are explained in the 'Rulesets', 'Dialects' and 'Hosting 
  language' pages of this document. 
   
terminology:
  - term: template 
    definition: |-
      Source code respecting the wlang grammar, and attached to a given <em>wlang 
      dialect</em>.
    example: |-
      <tt>Hello ${name}</tt>
  - term: dialect
    definition: |-
      Basically, <em>dialect</em> is used as a synonym for (programming) <em>language</em>.
      However _wlang_ uses a tree of dialects, allowing specializations: <tt>sql/sybase</tt>
      for example is the qualified name of a sub-dialect 'sybase' of the 'sql' dialect. 
      Dialects come with associated _encoders_.
    example: |-
      <tt>sql/sybase</tt>
  - term: wlang dialect
    definition: |-
      When we talk about a <em>wlang dialect</em>, we are actually refering to some 
      specialization of the wlang tag-based grammar: <tt>wlang/xhtml</tt> for example
      is the templating language _wlang_ proposes to generate xhtml pages. An 
      example of source code in that dialect has been shown before.
      In addition to its encoders a <em>wlang dialect</em> comes with its sets of _tags_ 
      and associated _rules_.
    example: |-
      <tt>wlang/xhtml</tt>
  - term: encoder
    definition: |-
      Text transformation (algorithm) applying some encoding conventions of a portion
      of a the target language generated by a dialect. HTML entities-encoding, SQL's back-quoting 
      are examples of encoders. Encoders are accessible through their qualified name (dialect/encoder).
    example: |-
      <tt>xhtml/entities-encoding</tt><br/><tt>sql/single-quoting</tt>
  - term: ruleset
    definition: |-
      Reusable set of <em>tags</em> associated to <em>rule</em>s.
    example: |-
      <tt>Imperative ruleset</tt><br/><tt>Encoding rulset</tt>
  - term: wlang tag
    definition: |-
      Special tags in the template, starting with wlang symbols and a number of wlang 
      blocks. A tag is associated with a wlang rule. 
    example: |-
      <tt>${...}</tt><br/><tt>?{...}{...}{...}</tt>
  - term: rule
    definition: |-
      Transformation semantics of a given <em>tag</em>. When wlang instantiates a
      template it simply replaces <em>wlang tags</em> by some <em>replacement value</em>
      (which is always a string). This value is computed by the rule attached to 
      the tag. Rule definition (see Rulesets tab on top of the page)
      explicitly describes the number of blocks it expects, in which dialect they 
      are parsed and instantiated and the way the replacement value is computed.
    example: |-
      <tt>^{wlang/active-string}{...}</tt><br/>
      Instanciates #1, looking for an encoder qualified name. Instanciates #2 in 
      the current dialect. Encode #2's instantiation using encoder found in (#1)
      and return the result as replacement value.
  - term: context
    definition: |-  
      Some rules allow code to be executed in the <em>hosting language</em> (the 
      definition explicitly announce it by putting <tt>wlang/hosted</tt> in the corresponding
      block). When doing so, this code is in fact executed in a given context that 
      provides the execution semantics.
  - term: hosting language
    definition: |-
      language (or framework) that executes wlang. More precisely, the hosting language
      is the one that rules what is considered as an executable expression in tags that
      relies on some execution semantics (like !{...} for example). See the 'Hosting language'
      section to learn more.
    example: |-
      ruby
rulesets: 
  - name: Basic 
    examples:
      - ["wlang/active-string", "Hello !{name}",                       "Hello O'Neil"]
      - ["wlang/active-string", "Hello %{wlang/dummy}{!{name}}",       "Hello !{name}"]
      - ["wlang/dummy",         "Hello %{wlang/dummy}{!{name}}",       "Hello %{wlang/dummy}{!{name}}"]
      - ["wlang/active-string", "Hello ^{plain-text/upcase}{!{name}}", "Hello O'NEIL"]
    rules:
      # !{wlang/hosted}
      - name:      "execution"
        symbol:    "!"
        signature: "!{wlang/hosted}"
        definition: |-
          Instantiates #1, looking for an expression of the hosting language. Evaluates it, 
          looking for any object. Converts it to a string (using to_s for example if Ruby is
          the hosting language) and returns the result as replacement value.
      
      # %{wlang/active-string}{...}
      - name:      "modulation"
        symbol:    "%"
        signature: "%{wlang/active-string}{...}"
        definition: |-
          Instantiates #1, looking for a dialect qualified name. Instantiates #2 
          according to the rules defined by that dialect and returns the #2's 
          instantiation as replacement value.
      
      # ^{wlang/active-string}{...}
      - name:      "encoding"
        symbol:    "^"
        signature: "^{wlang/active-string}{...}"
        definition: |-
          Instantiates #1, looking for an encoder qualified name. Instantiates #2 in 
          the current dialect. Encode #2's instantiation using encoder found in (#1) and
          returns encoding as replacement value.
      
      # ${wlang/hosted}
      - name:      "injection"
        symbol:    "$"
        signature: "${wlang/hosted}"
        definition: Same semantics as execution so far.
      
      # +{wlang/hosted}
      - name:      "inclusion"
        symbol:    "+"
        signature: "+{wlang/hosted}"
        definition: Same semantics as execution so far.

  - name: Encoding
    examples:
      - ["wlang/xhtml", "Hello &{name}",                       "Hello name"]
      - ["wlang/xhtml", "Hello &{<script>}",                   "Hello &lt;script&gt;"]
      - ["wlang/xhtml", "Hello &;{<script>}",                  "Hello &lt;script&gt;"]
      - ["wlang/ruby",  "puts 'Hello &'{name}'",               "puts 'Hello name'"]
      - ["wlang/ruby",  "puts 'Hello &'{!{name}}'",            "puts 'Hello O\'Neil'"]
      - ["wlang/ruby",  "puts 'Hello ' << '{name}'",           "puts 'Hello ' << 'O\'Neil'"]
      - ["wlang/sql",   "... WHERE name='{name}'",             "... WHERE name='O\'Neil'"]
      - ["wlang/sql/sybase",  "... WHERE name='{name}'",       "... WHERE name='O''Neil'"]
    rules:
      # &{...}
      - name:       "main-encoding"
        symbol:     "&"
        signature:  "&{...}"
        definition: "<tt>^{+{@parser.current_dialect}/main-encoding}{#1}</tt>"
    
      # &;{...}
      - name:       "entities-encoding"
        symbol:     "&;"
        signature:  "&;{...}"
        definition: "<tt>^{+{@parser.current_dialect}/entities-encoding}{#1}</tt>"
    
      # &'{...}
      - name:       "single-quoting"
        symbol:     "&'"
        signature:  "&'{...}"
        definition: "<tt>^{+{@parser.current_dialect}/single-quoting}{#1}</tt>"
    
      # &;{...}
      - name:       "double-quoting"
        symbol:     '&"'
        signature:  '&"{...}'
        definition: "<tt>^{+{@parser.current_dialect}/double-quoting}{#1}</tt>"
    
      # ${wlang/hosted}
      - name:      "injection"
        symbol:    "$"
        signature: "${wlang/hosted}"
        definition: "<tt>&{+{#1}}</tt>"
    
      # '{wlang/hosted}
      - name:      "single-quoted"
        symbol:    "'"
        signature: "'{wlang/hosted}"
        definition: |-
          <tt>'&'{+{#1}}</tt> (first single quote is kept in the result)
    
      # "{wlang/hosted}
      - name:      "double-quoted"
        symbol:    '"'
        signature: '"{wlang/hosted}'
        definition: |-
          <tt>"&"{+{#1}}</tt> (first double quote is kept in the result)
        
  - name: Imperative
    examples:
      - ["wlang/*", '?{true}{then}{else}',                         'then']
      - ["wlang/*", '?{/th/ =~ "not tat"}{then}{else}',            'else']
      - ["wlang/*", '?{authors.include? "blambeau"}{yes}{no}',    'yes']
      - ["wlang/*", '[*{authors as a}{"{a}"}{, }]', '["blambeau", "llambeau", "ancailliau"]']
    rules:
      # ?{wlang/hosted}{...}{...}
      - name:      "conditional<br/>(third block is optional)"
        symbol:    "?"
        signature: "?{wlang/hosted}{...}{...}"
        definition: |-
          Instantiates #1, looking for an expression in the hosting language. 
          Evaluates it, looking for a boolean value (according to boolean semantics 
          of the hosting language). If true, instantiates #2, otherwise instantiates 
          #3 if present, returning instantiation as replacement value.
    
      # *{wlang/hosted as x}{...}{...}
      - name:      "enumeration<br/>(third block is optional)"
        symbol:    "*"
        signature: "*{wlang/hosted as x}{...}{...}"
        definition: |-
          Instantiates #1, looking for an expression in the hosting language. Evaluates 
          it, looking for an enumerable. Iterates all its elements, instantiating #2 for 
          each of them (the iterated value is set under name x in the scope). If #3 is 
          present, it is instantiated between elements. Replacement is the concatenation
          of all these instantiations.

  - name: Context
    examples:
      - ["wlang/*", '={name as n}{Hello +{n}}',                      "Hello O'Neil"]
      - ["wlang/*", '={name as n}Hello +{n}',                        "Hello O'Neil"]
      - ["wlang/*", '#={name}{blambeau}{Hello +{name}} and +{name}', "Hello blambeau and O'Neil"]
      - ["wlang/*", '#={name}{blambeau}Hello +{name} and +{name}',   "Hello blambeau and blambeau"]
      - ["wlang/*", '={author as name}{Hello +{name}} and +{name}', "Hello blambeau and O'Neil"]
      - ["wlang/*", '={author as name}Hello +{name} and +{name}',   "Hello blambeau and blambeau"]
      - ["wlang/*", '%={wlang/dummy as hello}{Hello +{name}}{+{hello}}', "Hello +{name}"]
      - ["wlang/*", '^={plain-text/upcase as name}{+{author}}{Hello +{name}} and +{name}', "Hello BLAMBEAU and O'Neil"]
      - ["wlang/*", '^={plain-text/upcase as name}{+{author}}Hello +{name} and +{name}', "Hello BLAMBEAU and BLAMBEAU"]
      
    rules: 
      # ={wlang/hosted as x}{...}
      - name:      "assignment<br/>(second block is optional)"
        symbol:    "="
        signature: "={wlang/hosted as x}{...}"
        definition: |-
            Instantiates #1, looking for an expression in the hosting language. Evaluates 
            it, looking for any object. Without second block, expands the current scope with 
            'x' being bound to evaluation result. Otherwise, branches the current scope for
            the second block instantiation only and bind 'x' the same way (i.e. x will not be 
            available outside the second block). Returns an empty string as replacement value.
      # #={wlang/active-string}{...}{...}
      - name:      "block-assignment<br/>(third block is optional)"
        symbol:    "="
        signature: "#={wlang/active-string}{...}{...}"
        definition: |-
          Instantiates #1, looking for a variable name (say 'x'). Instantiates #2 in the current 
          dialect. Without third block, expands the current scope with 'x' being bound to #2's 
          instantiation. Otherwise, branches the current scope for the third block instantiation 
          only and binds 'x' the same way (i.e. x will not be available outside the third block). 
          Returns an empty string as replacement value.
      # %={wlang/active-string as x}{...}{...}
      - name:      "modulo-assignment<br/>(second block is optional)"
        symbol:    "%="
        signature: "%={wlang/active-string as x}{...}{...}"
        definition: |-
            Instantiates #1, looking for a dialect qualified name. Instantiates #2 according 
            to the rules defined by that dialect. Without third block, expands the current 
            scope with 'x' being bound to #2's instantiation. Otherwise, branches the current 
            scope for the third block instantiation only and binds 'x' the same way (i.e. x will 
            not be available outside the third block). Returns an empty string as replacement 
            value.
      # ^={wlang/active-string as x}{...}{...}
      - name:      "encoding-assignment<br/>(second block is optional)"
        symbol:    "^="
        signature: "^={wlang/active-string as x}{...}{...}"
        definition: |-
            Instantiates #1, looking for an encoder qualified name. Instantiates #2 in 
            the current dialect. Encode #2's instantiation using encoder found in (#1).
            Without third block, expands the current scope with 'x' being bound to #2's encoding. 
            Otherwise, branches the current scope for the third block instantiation only and binds 
            'x' the same way (i.e. x will not be available outside the third block). Returns an 
            empty string as replacement value.<br/>

  - name: Buffering
    rules:
      # <<{wlang/uri}
      - name:      "input"
        symbol:    "<<"
        signature: "<<{wlang/uri}"
        definition: |-
          Instantiates #1, looking for an uri. Returns the text content of the found 
          uri (#1) as replacement value.
      # >>{wlang/uri}
      - name:      "output"
        symbol:    ">>"
        signature: ">>{wlang/uri}{...}"
        definition: |-
          Instantiates #1, looking for an uri. Instantiates #2 in the current dialect,
          using file found in #1 as output buffer. Returns an empty string as replacement
          value
symbols:
  - name: exclamation mark
    symbol: '!'
    meaning: execution
    remark: should never be overrided as single
  - name: 'caret/circumflex'
    symbol: '^'
    meaning: explicit encoding
    remark: should never be overrided as single
  - name: percent
    symbol: '%'
    meaning: modulation
    remark: should never be overrided as single
  - name: double quote
    symbol: '"'
    meaning: double-quoting
  - name: dollar
    symbol: '$'
    meaning: 'main-encoding'
  - name: ampersand
    symbol: '&'
    meaning: encoding
  - name: single quote
    symbol: "'"
    meaning: single-quoting
  - name: asterisk
    symbol: '*'
    meaning: iteration
  - name: plus
    symbol: '+'
    meaning: inclusion
  - name: question mark
    symbol: '?'
    meaning: condition
  - name: at symbol
    symbol: '@'
    meaning: linking
  - name: tilde
    symbol: '~'
    meaning: matching
  - name: number sign  
    symbol: '#'
  - name: comma
    symbol: ','
  - name: minus (dash)
    symbol: '-'
  - name: dot
    symbol: '.'
  - name: forward slash
    symbol: '/'
  - name: colon
    symbol: ':'
  - name: 'semi-colon'
    symbol: ';'
  - name: equal sign
    symbol: '='
  - name: less than
    symbol: '<'
  - name: greater than
    symbol: '>'
  - name: vertical bar
    symbol: '|'
  - name: underscore
    symbol: '_'
    remark: cannot be used as tag symbol; reserved for escaping in future versions
  - name: back slash
    symbol: \
    remark: cannot be used as tag symbol; reserved for escaping in current version
  - name: left parenthesis
    symbol: '('
    remark: cannot be used as tag symbol; reserved for block delimiter 
  - name: right parenthesis
    symbol: ')'
    remark: cannot be used as tag symbol; reserved for block delimiter 
  - name: left bracket
    symbol: '['
    remark: cannot be used as tag symbol; reserved for block delimiter 
  - name: right bracket
    symbol: ']'
    remark: cannot be used as tag symbol; reserved for block delimiter 
  - name: left brace
    symbol: '{'
    remark: cannot be used as tag symbol; reserved for block delimiter 
  - name: right brace
    symbol: '}'
    remark: cannot be used as tag symbol; reserved for block delimiter 
          
    
    