== What is _wlang_ ?
_wlang_ is a simple, powerful, robust and secure <b>code generation</b>/<b>templating engine</b>
(at least, authors hope so ;-) Motivation for it can be found at http://www.revision-zero.org/wlang. 
It's main aim is to help you creating web pages, sql queries, ruby code (that is, generating code in 
general) without having to worry too much about html entities encoding, sql back quoting, string
escaping and the like. WLang proposes a generic engine that you can extend to fit your needs. It also 
proposes standard instantiations of this engine for common tasks such as creating SQL queries, instantiating 
web pages, etc.    

== Roadmap
- For terminology and a quick overview of _wlang_ for generating code, read on.
- For the current cheatsheet/specification see link://files/specification.html
- If you want to learn _wlang_ quickly, see the example directory or read examples
  in the {specification file}[link://files/specification.html] (if you understand 
  all examples in the specification file, then you probably master wlang.
- If you want a killer example (but simple) see the way the specification.html file
  is generated in doc/specification directory
- If you want to know which dialects are available (that is, in which target languages 
  you can generate code), see link://files/specification.html or read 
  the file lib/wlang/dialects/standard_dialects.rb in the source distribution.
- If you want to create your own wlang dialect, see WLang::Dialect::DSL
- If you think that your own dialect is of generic purpose and well-designed, if
  you have any question or want to contribute join us on 
  {redmine}[https://redmine.chefbe.net/projects/revision-zero-public].
  
== Overview
(for bold words, see terminology later) Basic usage of _wlang_ is as follows: 
you have a *template* file (written in a given _wlang_ *dialect*), you have some 
instantiation *context* (data provided through a Ruby Hash or a yaml file for 
example) and you would like to instantiate the template with that data.

Example: a template.whtml as follows
  <html>
    <head>
      <title>${title}</title>
    </head>
    <body>
      <h1>Hello ${who} !</h1>
    </body>
  </html>
  
Instantiation data is a hash containing values for _title_ and _who_. Instantiating 
the template is straightforward:

  require 'wlang'
  context = {"title" => "Hello world in WLang", "who" => "Alice"}
  WLang.file_instantiate("template.whtml", context, STDOUT)
  
=== Seems magic ... but is not!
- first of all, it <b>does not allow XSS attacks</b>: even if _who_ is a value
  like <tt>'<script>[some javascript code]</script>'</tt>, it will be automatically
  entities-encoded and will appear for itself, not allowing the browser to interpret
  it as javascript code.
- <b>it is not hardcoded</b>, but uses _wlang_ shortcuts: 
  - as you did not specify the _wlang_ dialect of your template, it has been infered
    as 'wlang/xhtml' from the file extension.
  - in this dialect, the wlang rule associated with the tag ${...} (<tt>${who}</tt> 
    for example) automatically replaces the tag by the context data under 'who' (in
    the hash), while taking care of applying entities-encoding.
- <b>${...} is only one available tag</b>. Actuall _wlang_ dialects come with a lot 
  of useful tags that provide shortuct to common tasks ... entities-encoding is only one ! 

== Terminology
_wlang_ comes with a well-defined terminology for the underlying abstractions. As 
the documentation uses it, you'll probably be happy to learn about the main abstractions
and associated terms.
[template] Source code respecting the wlang grammar, and attached to a given <em>wlang 
           dialect</em>. Asbtraction implemented by WLang::Template.
[dialect]  Basically, <em>dialect</em> is used as a synonym for (programming) <em>language</em>.
           However _wlang_ uses a tree of dialects, allowing specializations: <tt>sql/sybase</tt>
           for example is the qualified name of a sub-dialect 'sybase' of the 'sql' dialect. 
           Dialects come with associated _encoders_. Abstraction implemented by WLang::Dialect. 
[wlang dialect] When we talk about a <em>wlang dialect</em>, we are actually refering to some 
                specialization of the wlang tag-based grammar: <tt>wlang/xhtml</tt> for example
                is the templating language _wlang_ proposes to generate xhtml pages. An 
                example of source code in that dialect has been shown before.
                In addition to its encoders a <em>wlang dialect</em> comes with its sets of _tags_ 
                and associated _rules_. Abstraction implemented by WLang::Dialect as well as
                WLang::EncoderSet and WLang::RuleSet. 
[encoder set] Reusable set of <em>encoders</em>, attached to a dialect. Abstraction
              implemented by WLang::EncoderSet.
[encoder] Text transformation (algorithm) applying some encoding conventions of a portion
          of a the target language generated by a dialect. HTML entities-encoding, SQL's back-quoting 
          are examples of encoders. Encoders are accessible through their qualified name: xhtml/entities-encoding
          and sql/back-quoting in the examples. Abstraction implemented by WLang::Encoder.
[ruleset]  Reusable set of <em>tags</em> associated to <em>rule</em>s. Abstraction
           implemented by WLang::RuleSet.
[wlang tag] Special tags in the template, starting with wlang symbols and a number of wlang 
            blocks. A tag is associated with a wlang rule. Examples: <tt>${...}</tt> is a 
            tag with only one block, while <tt>?{...}{...}{...}</tt> is another tag but with 
            three blocks.  
[rule] Transformation semantics of a given <em>tag</em>. When wlang instantiates a
       template it simply replaces <em>wlang tags</em> by some <em>replacement value</em>
       (which is always a string). This value is computed by the rule attached to 
       the tag. Rule definition (see {specification}[link://files/specification.html])
       explicitly describes the number of blocks it expects, in which dialect they 
       are parsed and instantiated and the way the replacement value is computed.
       Example: <tt>^{wlang/active-string}{...}</tt> (also known as 'encoding') 
       instantiates #1, looking for an encoder qualified name. Instantiates #2 in 
       the current dialect. Encode #2's instantiation using encoder found in (#1)
[context] Some rules allow code to be executed in the <em>hosting language</em> (the 
          definition explicitly announce it by putting <tt>wlang/hosted</tt> in the corresponding
          block). When doing so, this code is in fact executed in a given context that 
          provides the execution semantics. Abstraction implemented in WLang::Parser::Context.
[hosting language] language (or framework) that executes wlang. In this case, it will be
                   <tt>ruby</tt>.